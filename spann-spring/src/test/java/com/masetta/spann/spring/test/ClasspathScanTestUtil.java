/**
 * Copyright 2010 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.masetta.spann.spring.test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Map;
import java.util.Set;

import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.BeanDefinitionHolder;

import com.masetta.spann.metadata.core.ClassMetadata;
import com.masetta.spann.metadata.util.EmptyArrays;
import com.masetta.spann.spring.MetadataVisitor;
import com.masetta.spann.spring.core.ClassPathScanner;

public class ClasspathScanTestUtil {

    /**
     * Convenience method to create and configure a ClassPathScanner for testing
     * 
     * @param visitors
     * @param packages
     * 
     * @return a ClassPathScanner configured with visitors as specified by the given
     *     arguments.
     */
    public static ClassPathScanner createClasspathScannr( MetadataVisitor<ClassMetadata>[] visitors ,
    		String packages ) {
        ClassPathScanner cps = new ClassPathScanner();
        if ( visitors.length > 0 )
        	cps.setMetadataVisitors( Arrays.asList( visitors ) );
        cps.setBasePackagesNames( packages );
        return cps;
    }
    
    /**
     * Convenience method to scan just one class with the given visitors and
     * return the BeanDefinitions which result from the scan.
     * 
     * Important: Implement names generated in this scan are different from those
     * generated by spring. The name generator used in this scan returns
     * names in the form "test:SimpleClassName".
     * 
     * @param cls a single class to scan.
     * @param existingBeanDefinitions
     * @param visitors
     * @return all bean definition holders created in the spann scan.
     */
    public static Set<BeanDefinitionHolder> visit( Class<?> cls , Map<String,BeanDefinition> existingBeanDefinitions, MetadataVisitor<ClassMetadata> ...visitors ) {
    	try {
	        ClassPathScanner cps = createClasspathScannr( visitors, cls.getPackage().getName() );
	        cps.setResourcePattern( cls.getSimpleName() + ".class" );
	        return cps.doScan( new RegistryImpl(existingBeanDefinitions) );
    	}
    	catch ( RuntimeException ex ) {
    		ex.printStackTrace( System.err );
    		throw ex;
    	}
    }

    private static class RegistryImpl implements ClassPathScanner.Registry {
    	
    	private Map<String,BeanDefinition> beans;

        public RegistryImpl(Map<String, BeanDefinition> beans) {
			super();
			this.beans = beans;
		}

		public String generateBeanName(BeanDefinition beanDefinition) {
            String[] tokens = beanDefinition.getBeanClassName().split("\\.");
            return "test:" + tokens[ tokens.length - 1];
        }

        public boolean isNameTaken(String name) {
            return false;
        }

		public BeanDefinition getBeanDefinition(String name) throws NoSuchBeanDefinitionException {
			if ( beans.containsKey( name ) )
				return beans.get( name );
			throw new NoSuchBeanDefinitionException( name );
		}

		public String[] getBeanDefinitionNames() {
			return new ArrayList<String>( beans.keySet() ).toArray( EmptyArrays.STRING );
		}
        
    }
}
