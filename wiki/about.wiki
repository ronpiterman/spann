= About Spann =

Spann is an extension library for [http://www.springsource.org the Spring Framework]. It provides an API to create arbitrary spring beans using any class metadata, including annotations, without (almost) any XML.

It's target is to reduce boilerplate code and configuration, similar to the [http://static.springsource.org/spring/docs/3.0.3.RELEASE/spring-framework-reference/html/extensible-xml.html XML Schema extension API] (introduced in Spring 2.0) only it uses class metadata (classes, fields, methods, and annotations information) instead of XML.

It adds *meta programming* capabilities (via annotations or any other class meatdata) to the spring container.

=== Class Metadata ===

The spann-metadata module provides an API to access the complete class metadata information (internally using [http://asm.ow2.org/ ASM]), with simple rule engine to define which metadata should be read from bytecode. Additionally any metadata that was not initially read is transparently lazy loaded on demand.

The metadata API is portable across different ASM versions and is not dependent on spring. When used with spring, spann-metadata uses the asm implementation delivered with spring, and does not introduce new dependencies. 

== But is'nt there a built-in annotation support in spring?  ==

Spring built in annotation support is not customizable: in spring 2.5, four annotations are predefined for different types of beans ( @Component, @Service, @Repository and @Conroller ).

For Spring 3.0, further annotations were introduced, but spring is lacking an API to 
handle custom annotations or any other class metadata. Annotations (and how spring handles them) are defined by the container. It remains an assignment for Container developers to introduce new annotations and it requires deep knowledge of container internals.

Sure, these annotations can be used as meta-annotations, allowing developers to introduce new annotations; bundling new functionality with these annotations is involved in either creating aspects for them, or handling them manually. 

Spring is missing an API, similar to the XML Schema extemsion API, to allow developers
to add (or manipulate) custom bean definitions using custom annotations.

== Spann's annotation support ==

The spring XML Schema extension API allows developers to handle custom XML to create spring beans. Spann allows them to do the same thing, but via Annotations (or any other class metadata).

=== How it works : A bird's-eye view ===

Spann scans selected packages by pattern and creates *class metadata*. It then passes this metadata to *visitors* which may create arbitrary bean definitions.

To simplify the handling of annotations, spann includes custom visitors and annotations providing a simple API for creating and handling of custom annotations.

=== Do I need it ? ===

There are many usecases for such functionality which all aim at reducing boilerplate code (and configuration) and making application code more precise and easier to maintain:

 *  Method implementation via metadata (for example auto creation of DAO implementation methods to perform JPA queries).
 *  Using templates of beans to wrap around a single method; for example for message (or JMS) listener or dispatcher methods, or implementation of any single method interface.


== Some examples ==


==== JPA ====

These annotations (and more) are implemented in spann-jpa:

{{{
@Dao
public interface UserDao extends BaseDao<User,Long> {

  // will perform "FROM User WHERE username = ?"
  @Finder(fromMethodName=true)
  User findByUsername( String username );

  // will perform "FROM User WHERE enabled = ?"
  // with the given position
  @Finder(fromMethodName=true)
  List<User> findByEnabled( boolean enabled , QueryPosition pos );

...

}}}

==== JMS ====

This is not implemented yet, but shows the direction.

With XML, one needs to create a jms listener container, and a listener adapter.
In spann it looks like that:

{{{
@Component
public class MyListener {

  @JmsListener(queue="queue-name")
  public void doSomethingWithMessage( TranslatedMessageObject in ) {
    ...
  }
}
}}}

With XML it is the above code (without the @JmsListener annotation) with some extra configuration (taken from the spring reference):

{{{
<bean id="messageListener"   class="org.springframework.jms.listener.adapter.MessageListenerAdapter">
    <constructor-arg>
        <bean class="jmsexample.MyListener"/>
    </constructor-arg>
    <property name="defaultListenerMethod" value="doSomethingWithMessage"/>
</bean>

<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
  <property name="connectionFactory" ref="connectionFactory"/>
  <property name="destination" ref="destination"/>
  <property name="messageListener" ref="messageListener" />
</bean>

}}}

==== A simple interface ====

Again, this is not implemented yet, but shows the direction...

Wrap an interface implementation bean around a method, for example for a very 
simple validator implementation.
{{{
@Component
public class MyValidators {

  @Validator
  public void validate( Person person , Errors errors ) { ... }

  @Validator
  public void validate( Address address , Errors errors ) { ... }

  ...

} }}}