= About Spann =

Spann is an extension library for the [http://www.springsource.org Spring Framework]. It provides an API for creating any spring beans based on annotation or any other class metadata, without (almost) any XML.

It's target is to reduce boilerplate code and configuration. It can be seen as a counterpart API to the [http://static.springsource.org/spring/docs/3.0.3.RELEASE/spring-framework-reference/html/extensible-xml.html XML Schema extension API] (introduced in Spring 2.0): instead of using XML it uses class metadata (classes, fields, methods, and annotations information).

Spann adds *meta programming* capabilities to the spring container using spring beans and (almost) without bytecode engineering.

=== spann-metadata Module ===

The spann-metadata module provides an API to access the complete class metadata information (internally using [http://asm.ow2.org/ ASM]), with simple rule engine to define which metadata should be read from bytecode. Additionally any metadata that was not initially read is transparently lazy loaded on demand.

The metadata API is portable across different ASM versions and is not dependent on spring. When used with spring, spann-metadata uses the asm implementation delivered with spring, and does not introduce new dependencies. 

== But is'nt there a built-in annotation support in spring?  ==

Spring built in annotation support is limited to specific usecases. In spring 2.5, four annotations are predefined for different types of beans ( @Component, @Service, @Repository and @Conroller ).

For Spring 3.0, further annotations were introduced, but spring is missing an API to 
allow custom bean creation using custom annotations or any other class metadata. Annotations (and how spring handles them) are defined by the container. It remains an assignment for Container developers to introduce new annotations and it requires deep knowledge of container internals.

Sure, the predefined @Component annotation (and others) can be used as meta-annotations. This allows developers to introduce new annotations; but bundling new functionality with these annotations is either done via aspects, or special handling. 

== Spann's annotation support ==

The spring XML Schema extension API allows developers to handle custom XML to create spring beans. Spann allows them to do the same thing, but via Annotations (or any other class metadata).

=== How it works : A bird's-eye view ===

Spann scans selected packages by name and creates *class metadata*. It then passes this metadata to *visitors* which may create arbitrary bean definitions.

To simplify the handling of annotations, spann includes custom visitors and annotations providing a simple API for creating and handling of custom annotations.

== Some examples ==


==== JPA ====


The following example is implemented in spann-orm.
Using this code, spann will implement the `UserDao` interface and
the annotated methods. This is done via CGLib (mostly by spring itself) and is very efficient at runtime.

(This is inspired by the  excellent 'polyforms' library. Polyforms offers similar functionality but relies on aspects. It uses XML and implements solutions for specific usecases. spann-spring and spann-metadata on the other hand provide an API for creating beans via annotations)

{{{
@Dao
public interface UserDao extends BaseDao<User,Long> {

  // will perform "FROM User WHERE username = ?"
  @DaoMethod
  @ByMethodName
  User findByUsername( String username );

  // will perform "FROM User WHERE enabled = ?"
  // with the given position
  @DaoMethod
  @ByMethodName
  List<User> findByEnabled( boolean enabled , QueryPosition pos );

  // simple jpql
  @DaoMethod
  @Jpql("FROM User AS u WHERE email = ?")
  User getUserByEmail( String email );

  // More advanced usage with MessageFormat arguments in the jpql.
  // calling findByRegdateOp( "username" , "<" , date );
  // will perform 'FROM User AS u WHERE u.regdate < ? ORDER BY u.username'
  @DaoMethod
  @Jpql("FROM User AS u WHERE u.regdate {1} ? ORDER BY u.{0}")
  List<User> findByRegdateOp( String sortfield , String regdateOp, Date minRegdate );

...

}}}

spann-orm contains many other features, you can take a look [SpannOrm here]

==== JMS ====

This is not implemented yet, but shows the direction.

With XML, one needs to create a jms listener container, and a listener adapter.
In spann it looks like that:

{{{
@Component
public class MyListener {

  @JmsListener(queue="queue-name")
  public void doSomethingWithMessage( TranslatedMessageObject in ) {
    ...
  }
}
}}}

With XML it is the above code (without the @JmsListener annotation) with some extra configuration (taken from the spring reference):

{{{
<bean id="messageListener"   class="org.springframework.jms.listener.adapter.MessageListenerAdapter">
    <constructor-arg>
        <bean class="jmsexample.MyListener"/>
    </constructor-arg>
    <property name="defaultListenerMethod" value="doSomethingWithMessage"/>
</bean>

<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
  <property name="connectionFactory" ref="connectionFactory"/>
  <property name="destination" ref="destination"/>
  <property name="messageListener" ref="messageListener" />
</bean>

}}}

==== A simple interface ====

Again, this is not implemented yet, but shows the direction...

Wrap an interface implementation bean around a method, for example for a very 
simple validator implementation.
{{{
@Component
public class MyValidators {

  @Validator
  public void validate( Person person , Errors errors ) { ... }

  @Validator
  public void validate( Address address , Errors errors ) { ... }

  ...

} }}}