<wiki:toc/>

= About Spann =

Spann is an extension library for the [http://www.springsource.org Spring Framework]. It provides an API for creating spring beans based on annotation or any other class metadata, without (almost) any XML.

It's target is to reduce boilerplate code and configuration. It can be seen as a counterpart API to the [http://static.springsource.org/spring/docs/3.0.3.RELEASE/spring-framework-reference/html/extensible-xml.html XML Schema extension API] (introduced in Spring 2.0): while the latter enables usign XML Schemas to simplify XML configuration and creating complex bean strtctures, spann allows developers do it using annotations or any other class metadata (classes, generics, fields, methods).

Spann adds *meta programming* capabilities to the spring container without (almost) any bytecode engineering. 

== But is'nt there a built-in annotation support in spring?  ==

Spring built in annotation support is limited to specific usecases. In spring 2.5, four annotations are predefined for different types of beans ( @Component, @Service, @Repository and @Conroller ).

For Spring 3.0, further annotations were introduced, but spring is missing an API to 
allow custom bean creation using custom annotations or any other class metadata. Annotations (and how spring handles them) are defined by the container. Introducing new annotations is very demanding and requires both knowledge of container internals and 

== How it works : A bird's-eye view ==

Similar to spring's component scan, spann scans resources by pattern under selected packages and creates *class metadata*. Instead of processing this metadata itself, like spring does, spann passes this metadata together with a `ScanContext` to *visitors*. Through the `ScanContext`, the visitors may create arbitrary bean definitions.

*The Default Visitor* searches classes for the `@Visitor` meta-annotation. The `@Visitor` meta-annotation specifies a delegate visitor. This allows annotations to be self-containing and define their visitor themselves, without the need to add visitors to the spann-spring configuration.

*The Scan Context* provides a simple API to allows different visitors to "play together" by giving bean definitions a "semantic" in a "scope" ("attaching" them to a metadata in the current tree). This allows other visitors to pick up the bean definitions and manipulate them.

To simplify the handling of annotations, the *spann-spring* module includes custom visitors and annotations providing a simple API for creating and handling of custom annotations.

=== spann-metadata Module ===

The [spann-metadata] module was developed to give metadata visitors access to *any class metadata* in any depth, also outside the scanned classes. It provides an API to access the complete class metadata information (internally using [http://asm.ow2.org/ ASM]), without loading the classes.

Initially, [spann-metadata] reads only a small part of the available class metadata, making everything else transparently available via on demand lazy loading. 

It is independent of spring and can be used by any application which needs simple access to class metadata information.

To define which metadata is read and which is lazy-loaded, [spann-metadata] uses a simple rule engine.

The metadata API is portable across different ASM versions and is not dependent on spring. When used with spring, [spann-metadata] uses the asm implementation delivered with spring, and does not introduce new dependencies.

== Usecase examples ==

=== JPA ===

  The following example is implemented in [spann-orm].
  Using this code, spann will implement the `UserDao` interface and
  the annotated methods. This is done via CGLib (mostly by spring itself) and is very efficient at runtime.

  (This is inspired by the  excellent 'polyforms' library. Polyforms provides similar   functionality but relies on aspects. It uses XML and implements solutions for specific usecases. spann-spring and spann-metadata on the other hand provide an API for creating beans via annotations)
  {{{
@Dao
public interface UserDao extends BaseDao<User,Long> {

  // will perform "FROM User WHERE username = ?"
  @DaoMethod
  @ByMethodName
  User findByUsername( String username );

  // will perform "FROM User WHERE enabled = ?"
  // with the given position
  @DaoMethod
  @ByMethodName
  List<User> findByEnabled( boolean enabled , QueryPosition pos );

  // simple jpql
  @DaoMethod
  @Jpql("FROM User AS u WHERE email = ?")
  User getUserByEmail( String email );

  // More advanced usage with MessageFormat arguments in the jpql.
  // calling findByRegdateOp( "username" , "<" , date );
  // will perform 'FROM User AS u WHERE u.regdate < ? ORDER BY u.username'
  @DaoMethod
  @Jpql("FROM User AS u WHERE u.regdate {1} ? ORDER BY u.{0}")
  List<User> findByRegdateOp( String sortfield , String regdateOp, Date minRegdate );

...

  }}}

  spann-orm contains many other features, you can take a look [SpannOrm here]

=== JMS ===

  This is not implemented yet, but shows the direction.

  With XML, one needs to create a jms listener container, and a listener adapter.
  In spann it as simple as:
  {{{
@Component
public class MyListener {

  @JmsListener(queue="queue-name")
  public void doSomethingWithMessage( TranslatedMessageObject in ) {
    ...
  }
}
  }}}

  With XML it is the above code (without the @JmsListener annotation) with some extra configuration (taken from the spring reference):
  {{{
<bean id="messageListener"   class="org.springframework.jms.listener.adapter.MessageListenerAdapter">
    <constructor-arg>
        <bean class="jmsexample.MyListener"/>
    </constructor-arg>
    <property name="defaultListenerMethod" value="doSomethingWithMessage"/>
</bean>

<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
  <property name="connectionFactory" ref="connectionFactory"/>
  <property name="destination" ref="destination"/>
  <property name="messageListener" ref="messageListener" />
</bean>

  }}}

=== A simple interface ===

  Again, this is not implemented yet, but shows the direction...

  Wrap an interface implementation bean around a method, for example for a very simple validator implementation.
  {{{
@Component
public class MyValidators {

  @Validator
  public void validate( Person person , Errors errors ) { ... }

  @Validator
  public void validate( Address address , Errors errors ) { ... }

  ...

} 
  }}}