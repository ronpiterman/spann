#summary spamm-orm module
= Introduction =

The target of spann-orm module is to provide implementation of common ORM related usecases.

Currently implemented are:

  * JPA based DAOs

== JPA DAOs ==

JPA DAOs method replacement uses spann-spring's `GenericMethodReplacer` class.
This allows developers to customize and extend the `@DaoMethod` for (almost) any JPA Query related use.

=== Syntax ===

==== `@Dao`====

  A Dao must be defined in either an interface extending `BaseDao<Entity,PrimaryKey>` 
  or in an (optionally abstract) class extending `BaseDaoImpl<Entity,PrimaryKey>`.

  {{{
  @Dao
  public interface UserDao extends BaseDao<User,Long> { ... }
  
  @Dao
  public /* abstract ?*/ class UserDao extends BaseDaoImpl<User,Long> { ... }
  }}}

==== `@DaoMethod`====

  The `@!DaoMethod` annotation delegates the annotated method to a `GenericMethodReplacer.

  The `op` attribute defines which method to call on the JPA Query to create the result: `getResultList()`, `getSingleResult()` or `executeUpdate()`. The default is to detect the op from the method name and return type: 
    * `update...` will execute an update 
    * `get...` will get a unique result 
    * All other method names will use `getResultList()`; if the method does not return a `Collection` or a `List`, the first element in result list will be returned ("find first or null").

  <b>Dynamic argument mapping</b>

  A important feature of the `@DaoMethod` annotation is the dynamic use of arguments.
  Method arguments are "consumed" by call-context handlers, allowing some arguments to be used as query arguments, other as Jpql replacement (`{0},{1}` etc), and yet others for any other use. 

  For example, the `!QueryPosition` class, which can be used with any `@DaoMethod`. An argumnet of this
  class will be consumed and will set the `firstResult` and/or `maxResults` property of the JPA Query.

  <b>Usage</b>

  The `@!DaoMethod` annotation requires at least one more annotation which indicates how to create the query (technically spoken: to set the `contextFactory` property of the `GenericMethodReplacer`).

  Currently the annotations `@ByMethodName`, `@Jpql` and `@NamedQuery` are implemented. (Developers can create other custom annotations).

==== `@ByMethodName` ====

  The `@ByMethodName` annotations creates a JPQL query from the method name. It can be used for very simple queries which make a single use of each argument with the "=" operator.

  See the API Docs for the supported syntax. 

  Some examples of the supported method name syntax: `findAll(), findByName(..), count(), countByName(..), countDistinctNameByCountry(..), avgSallaryByDepartment(..), maxSallaryByPosition(..), sumAmountByDepartment(..)`

==== `@Jpql`====

  Executes a given JPQL query.

  The JPQL may contain simple argument replacements in form of `{0}`, `{1}` etc. indicating a method argument index. This allows great flexibility in creating dymanic queries in which order-by columns or any other token in the query is dynamicaly replaced by a method argument.

  The JPQL Annotation Visitor uses internally MessageFormat to embed the method arguments
  in the query, however *only the simple syntax of {n}* should be used. 

  Any arguments used as JPQL Token replacement will be excluded from the query arguments.

  For example:

  {{{
  @DaoMethod
  @Jpql("FROM User AS u WHERE u.role = ?")
  List<User> findUserByRole( String role );

  @DaoMethod
  @Jpql("FROM Department AS d WHERE d.budget {3} ? ORDER BY d.{1} {2}")
  List<Department> findByBadget( 
    QueryPosition qp,  // #0 , will be consumed to set firstResult/maxResults.
    String orderField, // will replace {1}
    String ascOrDesc,  // will replace {2}
    String budgetOp,   // will replace {3}, can be any Jpql Op, such as "=","!=" etc.
    BigDecimal budget);// will be used as query argument 
  }}}
