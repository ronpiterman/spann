= About Spann =

Spann is a Java Library for the Spring Framework which adds generic api for annotation support to the spring container.

It relates to spring's annotation support the same way the "XML Schema Extension" (introduced in Spring 2.5) relates to spring's XML configuration: it allows developers to hook into the bean definition creation phase. 

Spann introduces *meta programming* via annotations (or any other class meatdata) to the spring framework.

== Spring's build in annotation support ==

Spring built in annotation support is of a static nature: in spring 2.5, four annotations are predefined for different types of beans ( @Component, @Service, @Repository and @Conroller ).

For Spring 3.0, further annotations were introduced, but the still it remains static in nature: Annotation classes (and how spring interprets them) are defined by the container. Defining new Annotations with new functionality remains an assignment for Container developers and requires deep knowledge of the Container internals.

== Spann's annotation support ==

Spann is created to change this and allow application developers to easily define annotations and their functionality inside the spring container.

There are many usecases for the need of such a functionality. To name a few:

 *  Custom proxy creating as implementation for an interface (Auto creation of DAO implementation methods).
 *  Implementing "strategies" by wrapping a bean's Method by a strategy implementation object and configuring it via annotations.

== Technical overview ==

Spann consists of 2 core modules (or maven projects):

=== org.spann:spann-metadata ==

The metadata module provides a complete Metadata scanning facility. It uses asm visitors
to extract metadata from selected classes.

Main features of spann-meatdata are:

 *  API to refelect all java metadata of the target classes (with exception of code instructions) without loading *any* of the scanned classes. 
 *  Rule based scanning: API to optimize the scan by defining which metadata artifacts are read and which remain ignored.
 *  Lazy loading of all unloaded metadata on demand. For example: metadata of super classes, methods etc is transparently lazy-loaded on demand.
 *  Rule based lazy loading: API to define how much metadata is lazy loaded on demand. For example: when lazy-loading methods of a class, load also method-annotations.
