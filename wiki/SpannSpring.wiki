= Introduction =

*spann-spring* provides advanced annotation support for the spring framework. It facilitates spann-metadata to produce metadata which reflects java classes

= User's guide =

== Integrating in a spring context ==

*Add the jars*: first you need to add `spann-metadata.jar`and `spann-spring.jar` to your class path. If you are using Maven or Ivy, see [Maven] for repository and group- and artifact ids.

*Add the xml*: second you need to used the following XML to add spann-spring to the spring application context:

{{{
TODO
}}}

*conflict with spring component scan*: spann should apear in the XML after spring's component scann element. Since spann is aware of spring, this allows annotation visitors to avoid double definition of beans. 

One situation where such a conflict might occur is when a non abstract class is annotated with a spann annotation which is itself annotated by @Component. An example is the @Dao annotation, which is itself annotated with @Repository (in order to leverage Spring's exception translation). To avoid such conflicts, make sure that such annotations are only used with abstract classes or interfaces. 




= Developer's Guide =
Add your content here.

== Understanding the attach semantics ==

To allow visitors to share references to bean definitions and allow them
to reference or manipulate bean definitions created earlier (either by the same
visitor or by other visitors), visitors can _attach_ any !BeanDefinitionHolder to a metadata scope.

_Attaching_ a BDH to a given metadata and to a given scope will
 #  give the bean a certain semantic (role) for the given metadata, and
 #  make the bean unique by class name in the given scope (this is only forced by the attach method and does not constrain spring or creation of other beans).

For example, if a visitor needs to create an auxiliary bean which should be referenced
by all invocation to this visitor (e.g. to be injected to other beans created by this visitor), it can attach it to the global scope.

Or, if a method-annotation visitor needs to create an auxiliary bean which should be referenced only for other "visits" to methods of the same class, it can attach it to the CLASS scope. Later, when visiting other methods in the same class, the attached bean can be obtained from the !ScanContext. When visiting methods of other classes, another bean needs to be created for that class.

By convension, the `"main"` role is used for the main bean of any artifact.

=== API ===

To attach a BDH, a visitor should call 

{{{
void attach( BeanDefinitionHolder bdh, Metadata metadata , Artifact attachScope, String role );
}}}

on the ScanContext.

The given BDH is attach to 
 #  The given metadata with the given role.
 #  To the given scope with the BDH's full qualified class name.

To retrieve the bean, a visitor may call 

{{{
BeanDefinitionHolder getBeanDefinitionHolder( Metadata metadata, Artifact attachMetadataArtifact , String beanRole );
}}}
where scope is the Artifact corresponding to the *attach* metadata.

The same method can be used with a different scope and different role to obtain the same bean, namley (watch for the argument names):

{{{
BeanDefinitionHolder getBeanDefinitionHolder( Metadata metadata, Artifact attachScope , String fqClassName );
}}}

So the bean can be looked up by either 
 # the attach-metadata-artifact and attach-role, or (2) 
 # by the attach-scope and the bean's classname.

For convenient creating of dependencies, visitors can use 

{{{
VisitorSupport.getOrCreateAndAttach( ScanContext context, Metadata metadata , 
            Artifact scope, String role, Object source , String clazz )
}}}
to create a bean reference and attach it to a scope and a role. This method will lookup the needed bean in the given scope. If the bean does not exist, a new bean is created and attached to the given scope and role. `getOrCreateAndAttach` returns the bean name of the needed bean.